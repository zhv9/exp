# 散列表

主要是通过散列函数，将 key 散列，然后插入对应的数组位置中。所以在查找的时候就可以直接通过数组下标查找即可。

## 散列函数设计要求

1. 散了函数计算得到的散列值为非负整数
2. 如果 key1 = key2，那 hash(key1) == hash(key2)
3. 如果 key1 != key2，那 hash(key1) != hash(key2)

前两个问题不大，但是第三个可能有问题，因为毕竟散列函数是数据的摘要，有可能出现两个不同数据的散列值相同。这样的话，就要找方法解决这种冲突。

## 散列冲突解决

有两种方法：开放寻址法和链表法

### 开放寻址法

开放寻址法是在发现已经占用，则找到下一个空的位置放当前数据。找数据的时候，就先根据散列值找到该元素，如果不是的话，就继续向下找(都是散列值相同的)，直到找到空闲的位置。

由于找到空闲的位置后，就是表中没有这个数据，那么删除的时候就不能简单的删除，而是给一个删除标记。

还可以用二次探测和双重散列的方法来找新槽位。

**装载因子**：表示散列表中空闲槽位的多少。

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```

### 链表法

每个槽都是一个链表，在冲突时，向链表后添加数据即可。

## 设计散列函数

- 散列函数不能太复杂，复杂会影响散列表性能
- 散列函数生成的值要尽可能随机并且均匀分布
- 实际还要考虑关键字长度、特点、分别和散列表大小

## 装载因子过大时动态扩容

装载因子过大时，空闲位置越少，散列冲突也就会越多，插入操作要多次寻址或拉很长的链。

### 动态扩容的设计

动态扩容的话，就会申请一个新空间，然后把现有数据搬移过去，但是由于空间大了，散列值就需要重新计算每个数据的存储位置。所以插入操作的时间复杂度最好情况下是O(1)最坏情况下是O(n)，通过均摊，接近最好情况O(1)。

但是这样做的话，虽然平均O(1)但是某次操作由于装载因子达到阈值，在扩容再插入的操作可能会很慢，这种随机的极慢操作会影响客户体验。所以一次性扩容的机制就不太合适了。

> 为了解决一次性扩容慢的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子达到阈值时，先申请新空间，并插入新数据。只在有新数据插入时，再从老散列表中搬移一个数据到新表中。经过多次操作，老散列表中的数据全部搬移到新表中。通过这样均摊操作，实现了任何情况下都是O(1)的时间复杂度。
>
> 查询操作则先在新表中查询，没有找到再到老表中查询。

如果考虑空间浪费的问题，在数据删除到一定情况下，也可以对空间缩容。

## 选择冲突解决方法

开放寻址法：

- 数据存在数组中，有效利用CPU缓存加快查询速度，并且易于序列化
- 删除数据的时候比较麻烦，需要特殊标记
- 所有数据存在一个数组中，相比链表法冲突的代价更高。装载因子接近1的话，就可能会有大量的散列冲突，导致大量探测、再散列
- 链表法更浪费内存空间

当数据量比较少，装载因子小的时候，适合采用开放寻址法

链表法：

- 对内存利用率比开放寻址法高，链表在需要的时候申请，不需要提前申请好
- 对大装载因子的容忍度高，质押散列函数的值随机均匀，装载因子大也只是链表长度变长而已，仍然比顺序查找快很多
- 如果存小对象，则由于指针占内存，整体的内存消耗就会翻倍。如果是大对象，则指针占用内存问题就不大了
- 链表的节点零散分布在内存中，对CPU缓存不友好
- 散列表中的链表可以改造成其他更高效的动态数据结构，比如跳表、红黑树。即便出现散列冲突的极端情况，也可以保证O(logn)的效率。

基于链表的散列表，适合存储大对象、大数据量的散列表。而且比开放寻址法更灵活支持更多优化策略。

## 工业级散列

初始大小：如果知道大概有多大数据量，能给个初始值会比较好

装载因子和动态扩容：一般最大装载因子是0.75。在元素个数超过0.75*capacity则扩容

散列冲突解决方法：对于JDK1.8的HashMap，当链表长度超过 8 时，转换为红黑树，少于 8 时，转化为链表。

散列函数：需要简单高效，分布均匀。

```java
int hash(Object key) {
  int h = key.hashCode()；
  return (h ^ (h >>> 16)) & (capacity -1); // capacity 表示散列表的大小
}
```
