# 时间复杂度分析

## T(n)

### 第一段代码

```js
function cal() {
  let sum = 0;
  let i = 1;
  for (; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

以上代码粗略估算的话，一行算作一个 unit_time，那么：

- 2，3 行分别需要 1 个 unit_time
- 4，5 行都运行了 n 遍，需要 `2n*unit_time`

所以这段代码总运行时间是：`(2n+2)*unit_time`

所有代码的执行时间**T(n)**与每行代码的执行次数成正比。

### 第二段代码

```js
function cal() {
  let sum = 0;
  let i = 1;
  let j = 1;
  for (; i <= n; ++i) {
    j = 1;
    for (; i <= n; ++i) {
      sum = sum + i + j;
    }
  }
  return sum;
}
```

同样按每个语句执行时间是 unit_time，那 T(n)：

- 2，3，4 行每行需要 1 个 unit_time
- 5，6 行执行了 n 遍，需要 `2n*unit_time`
- 7，8 行执行了 n^2 遍，需要 `2n^2*unit_time`

所以整段代码执行时间是，`T(n) = (2n^2+2n+3)*unit_time`

# O(n)

如果 n 非常大，则常量 3 对公式影响较小，那么可以得出所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

把这个规律总结成一个公式：

> T(n) = O(f(n))
>
> n：数据规模的大小
>
> f(n)：每行代码执行的次数总和
>
> O：表示代码的执行时间 T(n) 与 f(n) 表达式成正比

所以第一个例子中的 `T(n) = O(2n+2)`，第二个例子中 `T(n) = O(2n^2+2n+3)`

这就是大 O 时间复杂度表示法，这个实际上不具体表示代码真正的执行时间，而是代码执行时间随数据规模增长的变化趋势，所以也叫做**渐进时间复杂度**，简称时间复杂度。

当 n 很大时，公式中的常量、低阶、系数三部分并不左右增长的趋势，所以可以忽略。只需要记录一个最大量级就可以了，那么两段代码的时间复杂度就可以记为：

- T(n) = O(n)
- T(n) = O(n^2)

## 时间复杂度分析

### 只关注循环执行次数最多的一段代码

因为大 O 表示的是变化趋势。会忽略常量、低阶、系数，只需要记录一个最大阶的量级就可以了。

```js
function cal(n) {
  let sum = 0;
  let i = 1;
  for (; index <= n; index++) {
    sum = sum + i;
  }
  return sum;
}
```

刚才第一个例子中 2、3 行都是常量级执行时间，与 n 的大小无关，对复杂度没有影响。循环执行次数最多的是第 4、5 行代码，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。

### 加法法则

```js
function cal(n) {
  let sum_1 = 0;
  let p = 1;
  for (; p < 100; ++p) {
    sum_1 = sum_1 + p;
  }

  let sum_2 = 0;
  let q = 1;
  for (; q < n; ++q) {
    sum_2 = sum_2 + q;
  }

  let sum_3 = 0;
  let i = 1;
  let j = 1;
  for (; i <= n; ++i) {
    j = 1;
    for (; j <= n; ++j) {
      sum_3 = sum_3 + i * j;
    }
  }

  return sum_1 + sum_2 + sum_3;
}
```

这个代码分为三部分，sum_1、sum_2、sum_3。下面分析每一部分的时间复杂度：

> 总的时间复杂度就等于量级最大的那段代码的时间复杂度
>
> 公式：`T1(n) = O(f(n))`, `T2(n) = O(g(n))`；那么
>
> `T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))`

### 乘法法则

> 公式：`T1(n) = O(f(n))`, `T2(n) = O(g(n))`；那么
>
> `T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))`

也就是说，假如 `T1(n) = O(n)`, `T2(n) = O(n^{2})`, 则 `T1(n)*T2(n^{2}) = O(n^{3})`，具体代码上可以把乘法法则看作是**嵌套循环**

```js
function cal(n) {
  let ret = 0;
  let i = 1;
  for (; i < n; ++i) {
    ret = ret + f(i);
  }
}

function func(n) {
  let sum = 0;
  let i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

单独看 cal() 函数，如果 func() 只是普通操作，那么 4~6 行时间复杂度为 O(n)，但 func() 函数本身的时间复杂度也是 O(n)，所以整个 cal() 函数的时间复杂度就是：`O(n*n) = O(n^2)`

## 几种常见的时间复杂度

- 常量阶：O(1)
- 对数阶：O(logn)
- 线性阶：O(n)
- 线性对数阶：O(nlogn)
- 平方/立方/k 次方阶：O(n^{2}), O(n^{3}), O(n^{k})
- 指数阶：O(2^{n})
- 阶乘阶：O(n!)

这些可以分为两类：**多项式量级** 和 **非多项式量级(NP 非确定多项式)**。其中非多项式量级只有两个 O(2^n) 和 O(n!)，在 n 越来越大时，非多项式量级算法的执行时间会急剧增加，执行时间会无限增长。所以算法非常低效。

### O(1)

因为时时间复杂度表示法，所以和 n 无关的不管多少行都是 O(1)，而不是具体行数。一般只要不存在循环、递归语句，再多的代码复杂度都是 O(1)。

### O(logn)、O(nlogn)

```js
function cal(n) {
  let i = 1;
  while (i <= n) {
    i = i * 2;
  }
}
```

其中第 4 行是代码执行次数最多的，只要计算出这行代码执行了多少次，就能知道整段代码的时间复杂度。

从代码看出，变量 i 的值从 1 开始取值，每循环一次就乘以 2。大于 n 时循环结束。也就是变量 i 是一个等比数列：

```
2^{0} ... 2^{1} ... 2^{2} ... 2^{k} ... 2^{x} = n
```

通过 2^{x} = n 求解 x 这个问题，`x = log_{2}n`，也就是 `O(log_{2}n)`

因为对数之间时可以转换的，`log_{3}n` 就等于 `log_{3}2 * log_{2}n` 所以 `O(log_{3}n) = O(C * log_{2}n)`，因为常量 C 可以忽略，所以可以表示为 `O(logn)`。

O(nlogn) 就是利用乘法法则将一段 `O(logn)` 的代码循环执行 n 遍。归并排序、快速排序的时间复杂度都是 `O(nlogn)`。

### O(m+n)、O(m\*n)

```js
function cal(m, n) {
  let sum_1 = 0;
  let i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  let sum_2 = 0;
  let j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

因为很难判断 m 和 n 谁更大，所以省略任何一个都不行，所以上面的代码时间复杂度就是 O(m+n)。

加法法则就不是求 max 而是将两个相加。但是乘法法则依然还是原来那个乘法法则。

# 空间复杂度分析

空间复杂度分析其实和时间复杂度分析类似，也称为**渐进**空间复杂度分析，**表示算法的存储空间与数据规模之间的增长关系**。

```c++
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

第二行申请了一个空间存储变量 i，但是它时常量阶，跟数据规模 n 没有关系，所以忽略。第三行申请了一个大小为 n 的 int 类型数组，除此之外剩下的代码都没有占用更多空间，所以整段代码的空间复杂度就是 O(n)。

## 最好、最坏、平均时间复杂度分析

```js
// n表示数组array的长度
function find(array, n, x) {
  let i = 0;
  let pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```

这个代码的时间复杂度还是 O(n) 吗？

- 最好情况：要查找的值在数组第一位，复杂度也就是 O(1)
- 最坏情况：要查的的值没在数组中，复杂度也就是 O(n)
- 平均情况：需要计算概率，如下

要查找的变量 x 在数组中的位置有 n + 1 种情况，分别时 x 在(0~n-1) 中和 x 不在数组中

- x 不在数组中的概率为 1/2
- x 在数组中的概率是 1/2，在数组中时的每个位置的概率都为 1/n，所以 0~n-1 中任意位置的概率就是 `1/2 * 1/n = 1/2n`

如果把每种情况的发生概率考虑进去的话，时间复杂度：

```
1*1/2n + 2*1/2n + ... + n*1/2n + n*1/2 = (3n+1)/4
```

这个是加权平均值，复杂度去掉系数为 O(n)

## 均摊时间复杂度

```c++
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;

 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

这段代码的作用是实现了一个往数组中插入数据的功能，当数组满了以后用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 放到数组的第一个位置，然后再将新的数据插入。如果数组一开始就有空闲空间，则直接插入数据。

- 最理想情况下数组有空闲，则复杂度为 O(1)
- 最坏情况下数组满，需要遍历数组求和，则复杂度为 O(n)
- 平均时间复杂度：O(1)

假设数组长度为 n，根据位置不同可以分为 n 种情况，每种情况的时间复杂度为 O(1)。额外情况复杂度为 O(n)。而这 n+1 种情况发生的概率是一样的，都是 1(n+1)。所以加权平均复杂度：

```
1*1(n+1) + 1*1/(n+1) + ... + 1*1/(n+1) + n*1/(n+1) = O(1)
```

find() 在极端情况下才是 O(1)，而 insert() 在大部分情况下复杂度都为 O(1)，只有个别情况下是 O(n)。

针对特殊场景的复杂度分析，需要用一种更简单的分析方法：摊还分析法。得到的复杂度为**均摊时间复杂度**。

每一次 O(n) 插入操作，都跟着 n-1 次 O(1) 的插入操作，所以把耗时最多的那次操作均摊到接下来的 n-1 次耗时较少的操作上。这一组连续的操作的均摊时间复杂度就为 O(1)。

像这种大部分情况下时间复杂度都很低，只有个别情况复杂度高，而且这些操作之间存在前后连贯的时序关系，就可以将这一组操作放在一块分析。看能否将复杂度高的操作均摊到其他复杂度低的操作上。一般均摊时间复杂度就等于最好情况时间复杂度。

习题：

```c++
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10];
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是2倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

解析：

- 最好情况：数组没有满：O(1)
- 最坏情况：数组满：O(n)
- 平均：O(1)

第一种计算方法，是：(1 + 1 + ... + 1 + n)/(n+1) = O(1)
第二种计算方法，加权平均，是：`1*1/(n+1) + 1*1/(n+1) + ... + 1*1/(n+1) + n*1/(n+1) = 1`
第三种计算方法，均摊，是：前 n 个操作都是 O(1) 第 n+1 是 O(n)，所以将这个 O(n)，均摊到下 n 个 O(1) 上。所以整体是 O(1)
