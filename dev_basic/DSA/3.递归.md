# 递归

递归需要满足三个条件：

- 一个问题的解可以分解为几个子问题的解。自己在哪一排可以分解为前一排的人在哪一排。
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。“自己在哪一排”和前面一排人求解“自己在哪一排”的思路一样。
- 存在递归终止条件。第一排人不需要再询问任何人就知道自己在哪一排。

写递归代码最关键的是 写出**递推公式，找到终止条件**。

## 递推公式和终止条件

### 递推公式

假设有 n 个台阶，每次可以跨 1 个或者 2 个台阶，问有多少种走法。

实际上可以根据第一步的走法把所有的走法分为两类

- 第一步走了 1 个台阶，n 个台阶的走法就是先走 1 个台阶后，n-1 个台阶的走法。
- 第一步走了 2 个台阶，n 个台阶的走法就是先走 2 个台阶后，n-2 个台阶的走法。

所以 n 个台阶的走法就等于上面两种走法相加，公式就是。

```
f(n) = f(n-1) + f(n-2)
```

### 终止条件

最基本的终止条件就是 f(1)=1。这个条件需要拿比较小的数 n=2 和 n=3 实验一下。

n=2 时，`f(2)=f(1)+f(0)` 如果终止条件只有一个 f(1)=1 那 f(2)就无法求解了。所以除了 f(1)=1 外还应把 f(2)=2 作为一种终止条件。这里可以不考虑 f(0)=1 这种 0 个台阶有一种走法的情况。然后可以再拿 n=3 和 n=4 来验证一下这个终止条件是否足够并且正确。

公式和代码就是：

```
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

> 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

## 总结

### 理解和编写递归

在理解递归的时候，如果一个问题 A 可以分解为若干子问题 B、C、D，可以假设 B、C、D 以假解决，在此基础上思考如何解决问题 A。并且只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可。不需要已从一次往下思考子问题与子子问题之间的关系。

编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

### 递归需要警惕的问题：堆栈溢出和重复计算

堆栈溢出：需要限制递归调用的最大深度来解决这个问题，但在不确定当前栈深度的情况下不能完全解决当前问题。

重复计算：如果展开递归过程，会发现有很重复计算(例如算了很多次 f(3))，所以可以考虑通过一个数据结构(例如散列表)报错已求解过的 f(k)，当递归调用到 f(k)时，先查看是否已经求解过了，如果是则直接取值。

### 时间和空间复杂度

在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。

### 递归的利弊

利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。
