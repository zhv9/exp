# 不同的层次深度使用不同的桩


被测试代码 | 可以进行的操作 | 被测试类 | 工厂
---|---|---|---
层次深度1：类中的FileExtensionManager | 添加一个用作依赖项的构造函数参数。 | 被测试类中的成员是伪造的，其他代码都保持不变 | 无
层次深度2：从工厂类返回给被测试代码的依赖项 | 通过设置工厂类的**属性**，让工厂类返回伪造的依赖项。工厂类中的成员是伪造的 | 被测试类不变 | 设置工厂**属性**
层次深度3：返回依赖项的工厂类 | 把工厂类的实例替换为返回伪造依赖项的伪工厂。工厂是伪造的，并且返回一个伪依赖。 | 被测试类不变 | 伪工厂

下面是对上表的解释，添加一个构造函数层的参数会使事情变得复杂，选择第二层在这里是最简单的，因为它对代码改动最小。

1. 第一层，(在被测试类中伪造一个成员) 这种方法会改变使用被测试类的语义，除非有极好的理由，否则还是尽量避免这种做法。
2. 第二层，(在工厂类中伪造一个成员)这种方法需要了解什么代码会在什么时候调用这个工厂，也就是说，在轻松实现这个方法前还需要进行一些调查研究。理解一个没有接触过的基础代码是一项艰巨的任务，单这种方法还是比其他方法更合理。
3. 第三层，(伪造工厂)创建伪工厂实例，然后让它返回伪依赖项。把这个伪工厂赋给被测试类。这种比较不易理解，还是最好避免。
