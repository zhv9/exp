# 排序

## 分析排序效率

- 最好最坏和平均时间复杂度
  - 我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的。
- 时间复杂度的系数、常数和低阶
  - 在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
- 比较次数
  - 应该把比较次数和交换（或移动）次数也考虑进去。
- 排序算法的内存消耗：O(1)的排序算法是原地排序
- 排序算法的稳定性：指的是相同的数据在排序后他们的顺序有没有改变，这在数据有多个属性时非常重要。

## 冒泡排序的平均时间复杂度

对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。除了概率论的方法定量分析外，还有一种通过“**有序度**”和“**逆序度**”这两种概念分析的方法。

### 有序度

对于2, 4, 3, 1, 5, 6 这组数据的有序度为11，分别是：

> (2,4), (2,3), (2,5), (2,6), (4,5), (4,6), (3,5), (3,6), (1,5), (1,6), (5,6)

- 数组中具有有序关系的元素对的个数，有序元素对：a[i] <= a[j], 如果i < j。
- 6，5，4，3，2，1，有序度时 0。
- 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。这种也叫做**满有序度**
- 逆序度 = 满有序度 - 有序度

### 时间复杂度

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为**逆序度**，也就是n*(n-1)/2–初始有序度。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。

这种分析方法不严格但是很实用。

## 插入排序

将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入。

插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入，实际是让 a 在已排序区间做冒泡。

## 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

选择排序的时间复杂度和其他两个相同，但是选择排序是**不稳定**的排序算法。

## 为什么插入排序比冒泡排序更受欢迎

冒泡排序和插入排序的元素移动次数都等于原始数据的逆序度。但是从代码上看，冒泡排序的数据交换比插入排序的数据移动要复杂

- 冒泡排序需要 3 个赋值操作
- 插入排序需要 1 个赋值操作

```java
// 冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

// 插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

虽然冒泡和插入排序的时间复杂度都是O(n^2)，但是如果希望性能优化到极致，肯定首选插入排序。优化可参考希尔排序。

