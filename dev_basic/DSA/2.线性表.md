# 线性表

## 数组

- 数组是一种线性表，和列队、链表、栈相同
- 是一整块连续的内存空间，如果是自动扩容的数组容器，一般会申请一个新的1.5倍的连续空间，然后将原来的数据复制过去
- 随机访问的复杂度为 O(1)，但是查找则不是需要遍历整个数组。
- 随机访问时通过 `a[i]_address = base_address + i * data_type_size` 来计算对应地址
- 因为要保持内存中数据连续性，插入和删除操作比较低效，需要将插入位置后的数据向后移动，或在删除后将数据向前移动，平均时间复杂度为 O(n)
- 数组访问可能会越界，使用时需要特别关注

## 链表

- 链表也是一种线性表，包括单链表、循环链表和双向链表，与数组不同的是它不需要连续的内存空间
- 链表中除了记录数据外还记录了下一个数据的地址，或上一个数据的地址（双向链表），单项和双向链表最后一个后继指针为 NULL，而循环链表则是第一个数据的地址
- 链表随机访问时间复杂度为 O(n)，因为只能从第一个数据向后一个一个查找
- 插入和删除操作的时间复杂度为 O(1)，因为可以只改变前和后数据中的指针，而不需要像数组那样调整整个表的数据。双向链表在删除数据的时候不需要再进行一次遍历找到被删除数据前一个数据的地址，所以删除时会更高效一些
- 链表相对数组会使用更多的内存空间来记录前或后节点的地址，如果对链表进行频繁的插入和删除操作，就会导致频繁的内存申请和释放，容易造成内存碎片

### 链表实现缓存淘汰算法(LRU)

- 首先，链表中较老的数据放在链表的尾部，新或最近访问的数据在头部
- 如果新插入的数据在链表中，找到链表中对应的节点，然后删除该节点，再将该数据插入链表头部
- 如果新插入的数据不在链表中：
  - 链表未满时：直接插入头部
  - 链表已满时：删除尾部数据，并将新数据插入头部

### 单链表实现回文检查

回文字符串的意思就是正读和反读都一样的字符串，比如 level，noon

- 通过快慢指针，找到字符串中心点，慢指针每次移动一个一个数据位，快指针每次移动两个数据位
- 慢指针在移动到下一个数据前将当 next 指针指向设置为前一个数据的地址，这样的话就可以从中间数据再遍历回到头部
- 在快指针移动两个数据位时
  - 如果移动第一次就到尾部则该字符串字符数为单数，第二次到尾部的话，字符数为双数
  - 双数字符串在比较数据时，从慢指针当前指向的数据开始。单数字符串则从慢指针的下一个数据开始比较（单数字符串中间字符不用比较）
- 在开始比较后，需要恢复数据将 next 指针指回原来的地址，也就是再反序

时间复杂对为：O(n)
空间复杂度为：O(1)

### 编写链表

#### 指针

首先要理解指针的含义，指针其实就是引用。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。或者反过来说，指针中存储了这个变量的内存地址，指针就指向这个变量了，通过指针就可以找到这个变量。

代码中 `p->next = q` 就是说，p 节点中的 next 指针存储了 q 节点的内存地址。 `p-next = p->next->next` 代表 p 节点的 next 存储了 p 节点的下下一个节点的内存地址（等于删除了下一个节点）。

#### 注意内存泄漏


```c++
p->next = x;  // 将p的next指向x节点
x->next = p->next;  // 将x的next指向原先p下一个节点
```

在插入数据到当前节点后时，如果先把当前节点的 next 指向新节点，那么当前节点后面的节点就丢失了。所以需要先将新节点的 next 指向当前节点的 next 然后再将当前节点指向新节点。所以以上代码需要反过来写才行。

删除链表节点时，对于需要手动管理内存的语言，一定要记得手动释放内存空间，不然可能内存泄漏。

### 利用哨兵简化实现难度

插入节点的代码如下：

```c++
new_node->next = p->next;
p->next = new_node;
```

但是如果向一个空链表中插入第一个节点时就不能用了，这是需要判断 `head == null` 的情况，如果是 `null` 那么 `head = new_node`。

同样删除节点时，使用 `p->next = p->next->next` 就可以了，但是在 `head` 是最后一个的情况下，就不管用了，需要判断 `head->next` 是否为 `null`。

这时引入**哨兵**就可以简化代码。哨兵是**解决边界问题或特殊情况的判断**，不会直接参与业务逻辑。

由于空链表 `head=null` 表示链表中没有节点了，`head` 中存储了第一个节点的指针。如果引入哨兵节点，`head` 都会一直指向这个哨兵节点。这种有哨兵节点的链表叫**带头链表**。

使用带头链表就可以在插入和删除时使用相同的代码。

### 留意边界处理

使用如下几条来检查边界条件：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 举例画图

如果想不清楚的话，就把各种情况举个例子，画出插入前和插入后的链表变化，然后看着图写代码。

### 练习

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

## 栈

栈是先进后出，后进先出的数据结构。栈可以用数组或链表来实现，数组实现的栈叫做顺序栈，链表实现的是链式栈。

练习：

- 实现一个顺序栈和一个链式栈
- 动态顺序栈的时间复杂度
- 使用栈来计算表达式 3+5*8-6
- 使用栈来检查括号匹配

## 队列

先进先出就是“队列”，基本操作只有两个，入队 enqueue() 和出队 dequeue()。

可以用数组或链表实现队列。队列相对于栈只需要栈顶指针来说，队列则需要 head 和 tail 两个指针，分别表示队列头和尾。

### 数组队列

如果用数组实现队列，由于每次出队时 head 都会向后移动，在进行一定出队操作后，数组就没有空闲空间了。解决方法依然是数据搬移。但由于每次出队操作都相当于删除数组下标为 0 的数据，要搬移整个列队中的数据，以前的 O(1) 就变为O(n) 了。

改进方法就是在入队检查是否有空闲空间，在没有空闲空间时集中进行数据搬移操作。

### 循环队列

循环队列看起来就像一个环，把首尾相连成一个环。

比如队列大小为 8 时，如果 tail = 7，当有一个新的元素 a 入队时，放入下标为 7 的位置，但这个时候不把 tail 更新为 8，而是将其在环中后移一位到下标 0 的位置。

循环队列的关键是：确定好队空和队满的判定条件。

- 队空的判断条件仍然是 head == tail
- 队满的稍微复杂：由于 tail 指向的是下一个入队元素的地址，实际是没有存储数据的，那么当队满时 tail + 1 其实就是 head 的下标，即： `(tail + 1)%n=head`。

### 阻塞队列

在队列中没有数据时，阻塞出队操作。在队列满时，阻塞入队操作。其实就是一个典型的“生产者 -- 消费者”模型。

当“生产者”生产过快导致队列满时，就阻塞“生产者”生产，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。

基于阻塞队列还可以协调“生产者”和“消费者”的个数，来提高数据的处理效率。让多个“消费者”对应一个“生产者”。

### 并发队列

并发队列的主要问题是线程安全问题，因此需要在队列的入队和出队操作上加锁，来避免线程安全问题。

### 队列在线程池中的应用

在线程池中没有空闲线程时：

- 非阻塞的处理方式：直接拒绝认为请求
- 阻塞的处理方式：将请求排队，等有空闲线程时取出排队的请求继续处理。

基于链表的队列可以是无界队列，所以有可能会排很长的队，导致处理响应时间过长。

而基于数组的有界队列，队列的大小有限排队的请求超过队列大小时，其他请求就会被拒绝。这种方式对响应时间敏感的系统来说相对合理。设置一个合理的队列大小是很重要的。

对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。
